{% extends "layout.html" %}

{% block title %}My Resume Reviews - Pufferfish{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/resume_reviews.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/resume_viewer.css') }}">
{% endblock %}

{% block main %}
<!-- Resume Selector -->
<div style="max-width: 1200px; margin: 0 auto; padding: 20px;">
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px;">
    <label for="resume-selector" style="font-weight: bold;">Select Resume:</label>
    <select id="resume-selector" class="form-control" style="max-width: 300px;">
      {% for resume in user_resumes %}
      <option value="{{ resume._id }}" {% if resume._id==current_resume_id %}selected{% endif %}>
        {{ resume.title }}
      </option>
      {% endfor %}
    </select>
  </div>
</div>

<div class="resume-viewer-container">

  <!-- Column 1: Previous Button -->
  <div class="nav-col">
    <button id="prev-btn" class="nav-btn secondary outline" disabled>&lt;</button>
  </div>

  <!-- Column 2: PDF Viewer -->
  <main id="pdf-viewer">
    <div id="viewer" class="pdfViewer"></div>
  </main>

  <!-- Column 3: Comments Sidebar -->
  <aside id="comments-sidebar">
    <div class="reviewer-header">
      <small>Reviewer</small>
      <h5 id="reviewer-name" style="margin:0;">Loading...</h5>
    </div>

    <h6>Comments</h6>
    <div id="comments-list"></div>
  </aside>

  <!-- Column 4: Next Button -->
  <div class="nav-col">
    <button id="next-btn" class="nav-btn secondary outline" disabled>&gt;</button>
  </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="{{ url_for('static', filename='js/resume_viewer.js') }}"></script>
<script>
  const documentId = {{ resume_id | tojson }}; // resume_id logical key
  const pdfUrl = {{ resume_path | tojson }}; // streaming URL for PDF
  let reviews = {{ reviews | tojson }} || []; // array of { reviewer_id, reviewer_name, highlights }
  let currentReviewIndex = 0;

  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  const PDF_SCALE = 1.5;
  let pdfDocument = null;

  // Handle resume selection change
  document.addEventListener('DOMContentLoaded', function () {
    const resumeSelector = document.getElementById('resume-selector');
    if (resumeSelector) {
      resumeSelector.addEventListener('change', function () {
        const selectedId = this.value;
        window.location.href = '/resume-reviews?resume_id=' + selectedId;
      });
    }
  });

  // helper to create highlight rectangles
  function createHighlightRect(bounds, highlightId = null) {
    const rect = document.createElement("div");
    rect.className = "highlight-rect";
    rect.style.left = bounds.left + "px";
    rect.style.top = bounds.top + "px";
    rect.style.width = bounds.width + "px";
    rect.style.height = bounds.height + "px";

    if (highlightId) {
      rect.setAttribute("data-highlight-id", highlightId);
      rect.style.cursor = "pointer";
      rect.addEventListener("click", (e) => {
        e.stopPropagation();
        selectCommentById(highlightId);
      });
    }

    return rect;
  }

  // render highlights for a specific page using current review data
  function renderHighlights(pageNum, viewport, highlightLayer) {
    highlightLayer.innerHTML = "";

    const currentReview = reviews[currentReviewIndex];
    if (!currentReview) return;

    const highlights = currentReview.highlights || {};
    const pageKey = pageNum.toString();

    if (highlights[pageKey] && highlights[pageKey].length > 0) {
      highlights[pageKey].forEach((highlight) => {
        if (highlight.rects && highlight.rects.length > 0) {
          highlight.rects.forEach((rectData) => {
            const startPdf = [rectData.x, rectData.y];
            const endPdf = [
              rectData.x + rectData.width,
              rectData.y - rectData.height,
            ];

            const startViewport = viewport.convertToViewportPoint(
              startPdf[0],
              startPdf[1]
            );
            const endViewport = viewport.convertToViewportPoint(
              endPdf[0],
              endPdf[1]
            );

            const bounds = {
              left: Math.min(startViewport[0], endViewport[0]),
              top: Math.min(startViewport[1], endViewport[1]),
              width: Math.abs(endViewport[0] - startViewport[0]),
              height: Math.abs(endViewport[1] - startViewport[1]),
            };

            const rect = createHighlightRect(bounds, highlight.id);
            highlightLayer.appendChild(rect);
          });
        }
      });
    }
  }

  // re-render highlights on all visible pages
  function updateAllHighlights() {
    const pages = document.querySelectorAll(".page-container");
    pages.forEach(async (pageDiv, index) => {
      const pageNum = index + 1;
      const highlightLayer = pageDiv.querySelector(".highlight-layer");
      const pdfPage = await pdfDocument.getPage(pageNum);
      const viewport = pdfPage.getViewport({ scale: PDF_SCALE });
      renderHighlights(pageNum, viewport, highlightLayer);
    });
  }

  // main PDF render
  async function render() {
    const viewer = createResumeViewer({
      pdfUrl,
      scale: PDF_SCALE,
      renderHighlightsForPage: (pageNum, viewport, highlightLayer) =>
        renderHighlights(pageNum, viewport, highlightLayer),
    });

    await viewer.render();
    pdfDocument = viewer.getDocument();

    // initial UI state
    updateReviewerDisplay();
  }

  // update the UI for the current reviewer
  function updateReviewerDisplay() {
    const reviewerNameEl = document.getElementById("reviewer-name");
    const prevBtn = document.getElementById("prev-btn");
    const nextBtn = document.getElementById("next-btn");

    if (reviews.length === 0) {
      reviewerNameEl.textContent = "No Reviews";
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      renderComments(); // will clear comments
      updateAllHighlights(); // will clear highlights
      return;
    }

    const currentReview = reviews[currentReviewIndex];
    reviewerNameEl.textContent = currentReview.reviewer_name || "Anonymous";

    // update buttons
    prevBtn.disabled = currentReviewIndex === 0;
    nextBtn.disabled = currentReviewIndex === reviews.length - 1;

    // update content
    renderComments();
    updateAllHighlights();
  }

  // render comments sidebar
  function renderComments() {
    const commentsList = document.getElementById("comments-list");
    commentsList.innerHTML = "";

    const currentReview = reviews[currentReviewIndex];
    if (!currentReview) {
      commentsList.innerHTML = "<p>No comments available.</p>";
      return;
    }

    const highlights = currentReview.highlights || {};
    let allComments = [];

    Object.keys(highlights).forEach((pageKey) => {
      const pageHighlights = highlights[pageKey];
      if (Array.isArray(pageHighlights)) {
        pageHighlights.forEach((highlight, index) => {
          if (highlight && highlight.comment && highlight.comment.trim() !== "") {
            allComments.push({
              pageNum: parseInt(pageKey),
              highlight: highlight,
            });
          }
        });
      }
    });

    allComments.sort((a, b) => {
      if (a.pageNum !== b.pageNum) return a.pageNum - b.pageNum;
      const aTop = a.highlight.rects[0]?.y || 0;
      const bTop = b.highlight.rects[0]?.y || 0;
      return bTop - aTop;
    });

    if (allComments.length === 0) {
      commentsList.innerHTML = "<p>No comments yet.</p>";
      return;
    }

    allComments.forEach(({ pageNum, highlight }) => {
      const commentItem = document.createElement("div");
      commentItem.className = "comment-item";
      commentItem.setAttribute("data-highlight-id", highlight.id);

      const commentText = document.createElement("div");
      commentText.className = "comment-text";
      commentText.textContent = highlight.comment;
      commentItem.appendChild(commentText);

      commentItem.addEventListener("click", () => {
        selectComment(commentItem, highlight.id);
      });

      commentsList.appendChild(commentItem);
    });
  }

  function selectComment(commentElement, highlightId) {
    const commentsList = document.getElementById("comments-list");
    const allComments = commentsList.querySelectorAll(".comment-item");
    allComments.forEach((item) => item.classList.remove("selected"));
    commentElement.classList.add("selected");
    highlightYellowBoxes(highlightId);
  }

  function selectCommentById(highlightId) {
    const commentsList = document.getElementById("comments-list");
    const allComments = commentsList.querySelectorAll(".comment-item");
    allComments.forEach((item) => item.classList.remove("selected"));

    let targetItem = null;
    allComments.forEach((item) => {
      if (item.getAttribute("data-highlight-id") === highlightId) {
        item.classList.add("selected");
        targetItem = item;
      }
    });

    if (targetItem) {
      targetItem.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
    highlightYellowBoxes(highlightId);
  }

  function highlightYellowBoxes(highlightId) {
    const allHighlightRects = document.querySelectorAll(".highlight-rect");
    allHighlightRects.forEach((rect) => rect.classList.remove("active"));
    allHighlightRects.forEach((rect) => {
      if (rect.getAttribute("data-highlight-id") === highlightId) {
        rect.classList.add("active");
      }
    });
  }

  // event Listeners for Buttons
  document.getElementById("prev-btn").addEventListener("click", () => {
    if (currentReviewIndex > 0) {
      currentReviewIndex--;
      updateReviewerDisplay();
    }
  });

  document.getElementById("next-btn").addEventListener("click", () => {
    if (currentReviewIndex < reviews.length - 1) {
      currentReviewIndex++;
      updateReviewerDisplay();
    }
  });

  render();
</script>
{% endblock %}