{% extends "layout.html" %} {% block title %}My Resume Reviews - Pufferfish{%
endblock %} {% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/resume_reviews.css') }}" />
<link rel="stylesheet" href="{{ url_for('static', filename='css/resume_viewer.css') }}" />
{% endblock %} {% block main %} {% if error %}
<div class="container" style="margin-top: 2rem">
  <article style="text-align: center; padding: 2rem">
    <h3>Unable to Load Resume Reviews</h3>
    <p>{{ error }}</p>
    <p>
      <a href="{{ url_for('resume_form.upload_resume') }}" role="button">Upload a New Resume</a>
    </p>
  </article>
</div>
{% else %}
<div class="resume-viewer-container" style="margin-top: 20px">
  <!-- Column 1: Previous Button -->
  <div class="nav-col">
    <button id="prev-btn" class="nav-btn secondary outline" disabled>
      &lt;
    </button>
  </div>

  <!-- Column 2: PDF Viewer -->
  <main id="pdf-viewer">
    <div id="viewer" class="pdfViewer"></div>
  </main>

  <!-- Column 3: Comments Sidebar -->
  <aside id="comments-sidebar">
    <div class="reviewer-header">
      <small id="version-label">Loading version...</small>
      <h5 id="reviewer-name" style="margin: 0">Loading...</h5>
      <div style="margin-bottom: 0.5rem">
        <a id="edit-resume-btn" href="#" role="button" class="primary" style="width: 100%; padding: 0.25rem;">
          Edit This Resume
        </a>
      </div>
      <div style="
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-top: 0.5rem;
        ">
        <button id="prev-review-btn" class="secondary outline" style="padding: 0.25rem 0.5rem; font-size: 0.75rem"
          disabled>
          &lt; Prev Review
        </button>
        <small id="review-count" style="color: var(--pico-muted-color)">-/-</small>
        <button id="next-review-btn" class="secondary outline" style="padding: 0.25rem 0.5rem; font-size: 0.75rem"
          disabled>
          Next &gt;
        </button>
      </div>
    </div>

    <h6>Comments</h6>
    <div id="comments-list"></div>
  </aside>

  <!-- Column 4: Next Button -->
  <div class="nav-col">
    <button id="next-btn" class="nav-btn secondary outline" disabled>
      &gt;
    </button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="{{ url_for('static', filename='js/resume_viewer.js') }}"></script>
<script>
  /* eslint-disable */
  const resumeEntries = {{ resume_entries | tojson | safe }};
  const currentResumeId = {{ current_resume_id | tojson | safe }};
  let currentResumeIndex = Math.max(
    0,
    resumeEntries.findIndex((r) => r._id === currentResumeId)
  );
  if (currentResumeIndex === -1) currentResumeIndex = 0;
  let currentReviewIndex = 0;

  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  const PDF_SCALE = 1.0;
  let pdfDocument = null;
  let viewerApi = null;
  const pdfCache = new Map();

  async function getPdfData(url) {
    if (pdfCache.has(url)) {
      // pdf.js may transfer the underlying buffer to a worker, so return a copy
      const cached = pdfCache.get(url);
      return cached.slice();
    }
    const response = await fetch(url);

    // Check if the response is actually a PDF
    if (!response.ok) {
      throw new Error(`Failed to fetch PDF: ${response.status} ${response.statusText}`);
    }

    const contentType = response.headers.get('content-type');
    if (contentType && !contentType.includes('application/pdf')) {
      throw new Error(`Expected PDF but got ${contentType}. The resume file may not be uploaded correctly.`);
    }

    const buffer = await response.arrayBuffer();
    const data = new Uint8Array(buffer);
    pdfCache.set(url, data);
    return data.slice();
  }

  function getCurrentEntry() {
    return resumeEntries[currentResumeIndex] || null;
  }

  function getCurrentReviews() {
    const entry = getCurrentEntry();
    return (entry && entry.reviews) || [];
  }

  function updateVersionDisplay() {
    const versionLabel = document.getElementById("version-label");
    const prevBtn = document.getElementById("prev-btn");
    const nextBtn = document.getElementById("next-btn");
    const entry = getCurrentEntry();
    if (!entry) {
      versionLabel.textContent = "No resume";
      prevBtn.disabled = true;
      nextBtn.disabled = true;
      const editBtn = document.getElementById("edit-resume-btn");
      if (editBtn) editBtn.style.display = "none";
      return;
    }
    versionLabel.textContent = `${entry.title || "Resume"} (${currentResumeIndex + 1}/${resumeEntries.length})`;
    prevBtn.disabled = currentResumeIndex === 0;
    nextBtn.disabled = currentResumeIndex === resumeEntries.length - 1;

    // Update edit button
    const editBtn = document.getElementById("edit-resume-btn");
    if (editBtn) {
      editBtn.style.display = "inline-block";
      editBtn.href = `/resume/${entry._id}/edit`;
    }
  }
  // added button to navigate thru comments by diff reviewers
  function updateReviewNavigation() {
    const reviews = getCurrentReviews();
    const prevReviewBtn = document.getElementById("prev-review-btn");
    const nextReviewBtn = document.getElementById("next-review-btn");
    const reviewCountEl = document.getElementById("review-count");

    if (reviews.length === 0) {
      prevReviewBtn.disabled = true;
      nextReviewBtn.disabled = true;
      reviewCountEl.textContent = "0/0";
      return;
    }

    reviewCountEl.textContent = `${currentReviewIndex + 1}/${reviews.length}`;
    prevReviewBtn.disabled = currentReviewIndex === 0;
    nextReviewBtn.disabled = currentReviewIndex === reviews.length - 1;
  }

  // helper to create highlight rectangles
  function createHighlightRect(bounds, highlightId = null) {
    const rect = document.createElement("div");
    rect.className = "highlight-rect";
    rect.style.left = bounds.left + "px";
    rect.style.top = bounds.top + "px";
    rect.style.width = bounds.width + "px";
    rect.style.height = bounds.height + "px";

    if (highlightId) {
      rect.setAttribute("data-highlight-id", highlightId);
      rect.style.cursor = "pointer";
      rect.addEventListener("click", (e) => {
        e.stopPropagation();
        selectCommentById(highlightId);
      });
    }

    return rect;
  }

  // render highlights for a specific page using current review data
  function renderHighlights(pageNum, viewport, highlightLayer) {
    highlightLayer.innerHTML = "";

    const reviews = getCurrentReviews();
    const currentReview = reviews[currentReviewIndex];
    if (!currentReview) return;

    const highlights = currentReview.highlights || {};
    const pageKey = pageNum.toString();

    if (highlights[pageKey] && highlights[pageKey].length > 0) {
      highlights[pageKey].forEach((highlight) => {
        if (highlight.rects && highlight.rects.length > 0) {
          highlight.rects.forEach((rectData) => {
            const startPdf = [rectData.x, rectData.y];
            const endPdf = [
              rectData.x + rectData.width,
              rectData.y - rectData.height,
            ];

            const startViewport = viewport.convertToViewportPoint(
              startPdf[0],
              startPdf[1]
            );
            const endViewport = viewport.convertToViewportPoint(
              endPdf[0],
              endPdf[1]
            );

            const bounds = {
              left: Math.min(startViewport[0], endViewport[0]),
              top: Math.min(startViewport[1], endViewport[1]),
              width: Math.abs(endViewport[0] - startViewport[0]),
              height: Math.abs(endViewport[1] - startViewport[1]),
            };

            const rect = createHighlightRect(bounds, highlight.id);
            highlightLayer.appendChild(rect);
          });
        }
      });
    }
  }

  // re-render highlights on all visible pages
  function updateAllHighlights() {
    const pages = document.querySelectorAll(".page-container");
    pages.forEach(async (pageDiv, index) => {
      const pageNum = index + 1;
      const highlightLayer = pageDiv.querySelector(".highlight-layer");
      const pdfPage = await pdfDocument.getPage(pageNum);
      const viewport = pdfPage.getViewport({ scale: PDF_SCALE });
      renderHighlights(pageNum, viewport, highlightLayer);
    });
  }

  // main PDF render
  async function render() {
    const entry = getCurrentEntry();
    if (!entry) {
      const viewer = document.getElementById("viewer");
      if (viewer) viewer.innerHTML = "<p>No resumes found.</p>";
      return;
    }

    try {
      const pdfData = await getPdfData(entry.resume_path);

      viewerApi = createResumeViewer({
        pdfData,
        scale: PDF_SCALE,
        renderHighlightsForPage: (pageNum, viewport, highlightLayer) =>
          renderHighlights(pageNum, viewport, highlightLayer),
      });

      await viewerApi.render();
      pdfDocument = viewerApi.getDocument();

      // initial UI state
      updateReviewerDisplay();
      updateVersionDisplay();
      updateReviewNavigation();
    } catch (error) {
      console.error("Error loading PDF:", error);
      const viewer = document.getElementById("viewer");
      if (viewer) {
        viewer.innerHTML = `
          <div style="padding: 2rem; text-align: center;">
            <h3>Unable to Load Resume</h3>
            <p style="color: var(--pico-muted-color);">${error.message || 'The PDF file could not be loaded.'}</p>
            <p style="margin-top: 1rem; font-size: 0.875rem;">This resume may not have a PDF file uploaded. Please upload the resume again.</p>
          </div>
        `;
      }
    }
  }
  // update the UI for the current reviewer
  function updateReviewerDisplay() {
    const reviewerNameEl = document.getElementById("reviewer-name");
    const reviews = getCurrentReviews();

    if (reviews.length === 0) {
      reviewerNameEl.textContent = "No Reviews";
      renderComments(); // will clear comments
      updateAllHighlights(); // will clear highlights
      return;
    }

    const currentReview = reviews[currentReviewIndex];
    reviewerNameEl.textContent = currentReview.reviewer_name || "Anonymous";

    // update content
    renderComments();
    updateAllHighlights();
    updateReviewNavigation();
  }

  // render comments sidebar
  function renderComments() {
    const commentsList = document.getElementById("comments-list");
    commentsList.innerHTML = "";

    const reviews = getCurrentReviews();
    const currentReview = reviews[currentReviewIndex];
    if (!currentReview) {
      commentsList.innerHTML = "<p>No comments available.</p>";
      return;
    }

    const highlights = currentReview.highlights || {};
    let allComments = [];

    Object.keys(highlights).forEach((pageKey) => {
      const pageHighlights = highlights[pageKey];
      if (Array.isArray(pageHighlights)) {
        pageHighlights.forEach((highlight, index) => {
          if (highlight && highlight.comment && highlight.comment.trim() !== "") {
            allComments.push({
              pageNum: parseInt(pageKey),
              highlight: highlight,
            });
          }
        });
      }
    });

    allComments.sort((a, b) => {
      if (a.pageNum !== b.pageNum) return a.pageNum - b.pageNum;
      const aTop = a.highlight.rects[0]?.y || 0;
      const bTop = b.highlight.rects[0]?.y || 0;
      return bTop - aTop;
    });

    if (allComments.length === 0) {
      commentsList.innerHTML = "<p>No comments yet.</p>";
      return;
    }

    allComments.forEach(({ pageNum, highlight }) => {
      const commentItem = document.createElement("div");
      commentItem.className = "comment-item";
      commentItem.setAttribute("data-highlight-id", highlight.id);

      const commentText = document.createElement("div");
      commentText.className = "comment-text";
      commentText.textContent = highlight.comment;
      commentItem.appendChild(commentText);

      commentItem.addEventListener("click", () => {
        selectComment(commentItem, highlight.id);
      });

      commentsList.appendChild(commentItem);
    });
  }

  function selectComment(commentElement, highlightId) {
    const commentsList = document.getElementById("comments-list");
    const allComments = commentsList.querySelectorAll(".comment-item");
    allComments.forEach((item) => item.classList.remove("selected"));
    commentElement.classList.add("selected");
    highlightYellowBoxes(highlightId);
  }

  function selectCommentById(highlightId) {
    const commentsList = document.getElementById("comments-list");
    const allComments = commentsList.querySelectorAll(".comment-item");
    allComments.forEach((item) => item.classList.remove("selected"));

    let targetItem = null;
    allComments.forEach((item) => {
      if (item.getAttribute("data-highlight-id") === highlightId) {
        item.classList.add("selected");
        targetItem = item;
      }
    });

    if (targetItem) {
      targetItem.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }
    highlightYellowBoxes(highlightId);
  }

  function highlightYellowBoxes(highlightId) {
    const allHighlightRects = document.querySelectorAll(".highlight-rect");
    allHighlightRects.forEach((rect) => rect.classList.remove("active"));
    allHighlightRects.forEach((rect) => {
      if (rect.getAttribute("data-highlight-id") === highlightId) {
        rect.classList.add("active");
      }
    });
  }

  // event Listeners for Buttons
  document.getElementById("prev-btn").addEventListener("click", async () => {
    if (currentResumeIndex > 0) {
      currentResumeIndex--;
      currentReviewIndex = 0;
      await render();
    }
  });

  document.getElementById("next-btn").addEventListener("click", async () => {
    if (currentResumeIndex < resumeEntries.length - 1) {
      currentResumeIndex++;
      currentReviewIndex = 0;
      await render();
    }
  });

  // Review navigation buttons
  document.getElementById("prev-review-btn").addEventListener("click", () => {
    const reviews = getCurrentReviews();
    if (currentReviewIndex > 0) {
      currentReviewIndex--;
      updateReviewerDisplay();
    }
  });

  document.getElementById("next-review-btn").addEventListener("click", () => {
    const reviews = getCurrentReviews();
    if (currentReviewIndex < reviews.length - 1) {
      currentReviewIndex++;
      updateReviewerDisplay();
    }
  });

  render();
</script>
{% endif %} {% endblock %}